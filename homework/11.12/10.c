#include <stdio.h>
/*
 * 题目描述：阶乘求和取模
 * 
 * 输入：
 * - 第1行: 整数k (1 ≤ k ≤ 100)，表示测试数据的组数
 * - 随后k行: 每行一个正整数n (1 ≤ n ≤ 1000000)
 * 
 * 输出：
 * - k行: 每行一个整数，表示f(n) = (1! + 2! + ... + n!) % 1000000
 * 
 * 要求：
 * - 计算前n项阶乘之和并对1000000取模
 * - 即 f(n) = (∑(i=1 to n) i!) % 1000000
 * 
 * 注意：
 * - 当n ≥ 25时，n!的末尾会有多个0，且n! % 1000000 = 0
 * - 因此当n ≥ 25时，f(n) = f(24) （因为25!及之后的阶乘对1000000取模都为0）
 * - 实际只需要计算到min(n, 24)即可
 * 
 * 示例：
 * 输入:
 * 3
 * 1
 * 5
 * 10
 * 输出:
 * 1
 * 153
 * 37913
 * 
 * 解释:
 * f(1) = 1! % 1000000 = 1
 * f(5) = (1!+2!+3!+4!+5!) % 1000000 = (1+2+6+24+120) % 1000000 = 153
 * f(10) = (1!+2!+...+10!) % 1000000 = 37913
 * 
 * 约束：
 * - 1 ≤ k ≤ 100
 * - 1 ≤ n ≤ 1000000
 * - 模数为1000000
 * - 需要利用模运算性质和阶乘特性进行优化
 */
#define ll long long
ll memo[100001] = {-1};

ll jc(int n){
    if(n==0 || n==1){
        return 1;
    }
    if(memo[n]!=-1){
        return memo[n];
    }else{
        memo[n] = (n*jc(n-1))%1000000;
        return memo[n];
    }

}
void init(){
    for (int i=0;i<100001;i++){
        memo[i] = -1;
    }
    memo[0] = 1;
    memo[1] = 1;
}
int main(){
    int n;
    scanf("%d",&n);
    init();
    for(int i=0;i<n;i++){
        int a;
        ll sum=0;
        scanf("%d",&a);
        if(a>=25) a=24;
        if(a==0){
            printf("1\n");
            continue;
        }
        
        for(int j=1; j<=a; j++){
            sum = (sum + jc(j))%1000000;

        }
        printf("%lld\n",sum);
    }
}