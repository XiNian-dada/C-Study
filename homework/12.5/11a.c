#include "stdio.h"
#include "stdlib.h"
/*
 * 题目描述：排队动物
 * 
 * 难度：中等
 * 
 * 输入：
 * - 第1行：整数q，表示询问次数
 * - 对于每个询问：
 *   1. 第1行：整数n，表示队伍长度
 *   2. 第2行：n个整数，表示入队序列（同学进入队伍的编号顺序）
 *   3. 第3行：n个整数，表示出队序列（小J猜测的同学离开队伍的编号顺序）
 * 
 * 输出：
 * - 对于每个询问：如果可以以猜测的顺序离开，输出"YES"，否则输出"N0"
 * - 注意：输出是大写的YES和N0（N后是数字0，不是字母O）
 * 
 * 规则：
 * 1. 队伍是栈结构：只能从队尾进入和离开（后进先出）
 * 2. 同学按入队序列顺序进入队伍
 * 3. 任何时候，只有队尾（最后进入）的同学可以离开
 * 4. 需要判断是否能按出队序列的顺序离开队伍
 * 
 * 关键点：
 * - 这是一个栈的合法出栈序列判断问题
 * - 入队序列固定，判断出队序列是否合法
 * - 典型的栈混洗（stack permutation）问题
 * 
 * 示例1：
 * 输入:
 * 2
 * 5
 * 1 2 3 4 5
 * 5 4 3 2 1
 * 输出:
 * YES
 * 
 * 解释:
 * 入队：1,2,3,4,5
 * 出队：5,4,3,2,1
 * 这是典型的后进先出顺序，可以做到：
 * 1进→2进→3进→4进→5进→5出→4出→3出→2出→1出
 * 
 * 示例1第二个询问：
 * 输入:
 * 4
 * 1 2 3 4
 * 2 4 1 3
 * 输出:
 * N0
 * 
 * 解释:
 * 入队：1,2,3,4
 * 出队：2,4,1,3
 * 不可能实现：
 * 要第一个出队2，需要1先进，然后2进，然后2出
 * 然后要出队4，需要3、4进，然后4出
 * 此时栈中从底到顶是：1,3
 * 只能出队3，无法出队1，所以不可能
 * 
 * 算法：
 * 使用栈模拟过程：
 * 1. 遍历入队序列，将每个元素入栈
 * 2. 每次入栈后，检查栈顶是否等于当前出队序列的待出队元素
 * 3. 如果相等，则出栈，并移动出队序列指针
 * 4. 重复直到栈为空或入队序列遍历完
 * 5. 最后检查是否所有出队序列元素都匹配
 * 
 * 约束：
 * - q ≤ 10
 * - n ≤ 100000
 * - 需要使用栈数据结构模拟
 * - 时间复杂度O(n)
 * - 注意输出格式："N0"不是"NO"
 * 
 * 提示：
 * 1. 使用数组模拟栈以提高效率
 * 2. 注意栈的大小要足够（最大n）
 * 3. 使用指针而非STL栈可能更快
 * 4. 每组询问需要重置栈
 */
int main(){
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        int a;
        scanf("%d", &a);
        int* in_stack = (int*)malloc(sizeof(int) * a);
        int *out_stack = (int*)malloc(sizeof(int) * a);
        int* in_queue = (int*)malloc(sizeof(int) * a);
        for(int j = 0; j < a; j++){
            scanf("%d", &in_stack[j]);
        }
        for(int j = 0; j < a; j++){
            scanf("%d", &out_stack[j]);
        }
        int i_in = 0;
        int i_out = 0;
        int top = 0;

        while(i_out < a){
            if(top > 0 && in_queue[top - 1] == out_stack[i_out]){
                top--;
                i_out++;
            }
            else{
                if(i_in >= a){
                    printf("N0\n");
                    free(in_stack); 
                    free(out_stack);
                    free(in_queue);
                    goto end;
                }
                in_queue[top++] = in_stack[i_in++];
            }
        }
        printf("YES\n");
        free(in_stack);
        free(out_stack);
        free(in_queue);
        end:
    }
   
}
