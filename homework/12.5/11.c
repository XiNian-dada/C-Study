#include "stdio.h"
#include "stdlib.h"
// 由于你只使用了 stdio.h 和 stdlib.h 中的函数，我只保留了这两个必要的头文件。
/*
 * 题目描述：排队动物
 * 
 * 难度：中等
 * 
 * 输入：
 * - 第1行：整数q，表示询问次数
 * - 对于每个询问：
 *   1. 第1行：整数n，表示队伍长度
 *   2. 第2行：n个整数，表示入队序列（同学进入队伍的编号顺序）
 *   3. 第3行：n个整数，表示出队序列（小J猜测的同学离开队伍的编号顺序）
 * 
 * 输出：
 * - 对于每个询问：如果可以以猜测的顺序离开，输出"YES"，否则输出"N0"
 * - 注意：输出是大写的YES和N0（N后是数字0，不是字母O）
 * 
 * 规则：
 * 1. 队伍是栈结构：只能从队尾进入和离开（后进先出）
 * 2. 同学按入队序列顺序进入队伍
 * 3. 任何时候，只有队尾（最后进入）的同学可以离开
 * 4. 需要判断是否能按出队序列的顺序离开队伍
 * 
 * 关键点：
 * - 这是一个栈的合法出栈序列判断问题
 * - 入队序列固定，判断出队序列是否合法
 * - 典型的栈混洗（stack permutation）问题
 * 
 * 示例1：
 * 输入:
 * 2
 * 5
 * 1 2 3 4 5
 * 5 4 3 2 1
 * 输出:
 * YES
 * 
 * 解释:
 * 入队：1,2,3,4,5
 * 出队：5,4,3,2,1
 * 这是典型的后进先出顺序，可以做到：
 * 1进→2进→3进→4进→5进→5出→4出→3出→2出→1出
 * 
 * 示例1第二个询问：
 * 输入:
 * 4
 * 1 2 3 4
 * 2 4 1 3
 * 输出:
 * N0
 * 
 * 解释:
 * 入队：1,2,3,4
 * 出队：2,4,1,3
 * 不可能实现：
 * 要第一个出队2，需要1先进，然后2进，然后2出
 * 然后要出队4，需要3、4进，然后4出
 * 此时栈中从底到顶是：1,3
 * 只能出队3，无法出队1，所以不可能
 * 
 * 算法：
 * 使用栈模拟过程：
 * 1. 遍历入队序列，将每个元素入栈
 * 2. 每次入栈后，检查栈顶是否等于当前出队序列的待出队元素
 * 3. 如果相等，则出栈，并移动出队序列指针
 * 4. 重复直到栈为空或入队序列遍历完
 * 5. 最后检查是否所有出队序列元素都匹配
 * 
 * 约束：
 * - q ≤ 10
 * - n ≤ 100000
 * - 需要使用栈数据结构模拟
 * - 时间复杂度O(n)
 * - 注意输出格式："N0"不是"NO"
 * 
 * 提示：
 * 1. 使用数组模拟栈以提高效率
 * 2. 注意栈的大小要足够（最大n）
 * 3. 使用指针而非STL栈可能更快
 * 4. 每组询问需要重置栈
 */
// 使用全局指针定义输入/出队序列和辅助栈 S
int* in_seq;   // 入队序列 (Q_in)
int* out_seq;  // 目标出队序列 (P_out)
int* aux_stack; // 辅助栈 (S)

void solve() {
    int q;
    if (scanf("%d", &q) != 1) return; // 读取询问次数

    while (q--) {
        int n;
        if (scanf("%d", &n) != 1) return; // 读取队伍长度 n

        // 1. 内存分配
        in_seq = (int*)malloc(sizeof(int) * n);
        out_seq = (int*)malloc(sizeof(int) * n);
        // 辅助栈 S 必须能够容纳所有 n 个元素
        aux_stack = (int*)malloc(sizeof(int) * n); 

        // 2. 读取入队序列
        for (int i = 0; i < n; i++) {
            scanf("%d", &in_seq[i]);
        }

        // 3. 读取目标出队序列
        for (int i = 0; i < n; i++) {
            scanf("%d", &out_seq[i]);
        }

        // --- 4. 核心栈模拟逻辑 ---

        // i_in: 指向 in_seq 中下一个要入栈的元素索引 (0 到 n-1)
        int i_in = 0; 
        // i_out: 指向 out_seq 中下一个要匹配的目标元素索引 (0 到 n-1)
        int i_out = 0;
        // top: 栈顶指针，表示 aux_stack 中元素的数量 (栈顶元素的下一个空位置)
        int top = 0; 

        // 当目标出队序列 P_out 还没全部完成时，继续循环
        while (i_out < n) {
            
            // 检查情况 1: 栈顶是否匹配目标元素
            if (top > 0 && aux_stack[top - 1] == out_seq[i_out]) {
                // 匹配成功，执行出栈操作 (Pop)
                top--;      
                i_out++;    // 检查 P_out 的下一个目标
            } 
            
            // 检查情况 2: 栈顶不匹配，尝试从入队序列 Q_in 转移
            else {
                // 如果入队序列 Q_in 已经用完 (i_in >= n)
                if (i_in >= n) {
                    // 无法再推入新元素，且栈顶不匹配，说明失败
                    printf("N0\n");
                    goto cleanup; // 跳转到内存释放部分
                }
                
                // 将 in_seq[i_in] 入栈 (Push)
                aux_stack[top++] = in_seq[i_in];
                i_in++;
            }
        }

        // 循环结束，说明 i_out 成功到达 n，所有元素都按顺序出队
        printf("YES\n");

        // --- 5. 内存释放 ---
        cleanup:
        free(in_seq);
        free(out_seq);
        free(aux_stack);
    }
}

int main() {
    solve();
    return 0;
}