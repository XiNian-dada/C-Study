#include "stdio.h"
#include "stdlib.h"
#include "string.h"
/*
 * 题目描述：队列排序
 * 
 * 难度：简单
 * 
 * 输入：
 * - 第1行：整数n，表示人数（1 ≤ n ≤ 10^7）
 * - 第2行：n个整数，表示每个人号码牌上的数字（-10000 ≤ a_i ≤ 10000）
 * 
 * 输出：
 * - 一行：n个整数，按从小到大排序后的号码牌序列
 * - 数字之间用空格分隔
 * 
 * 要求：
 * - 将n个整数从小到大排序
 * - 负数排在前面，正数排在后面
 * - 相等数字的相对顺序可以任意（稳定或不稳定排序均可）
 * 
 * 示例1：
 * 输入:
 * 8
 * 0 20 60 -20 20 60 0 10
 * 输出:
 * -20 0 0 10 20 20 60 60
 * 
 * 示例2：
 * 输入:
 * 10
 * -9 -10 20 25 98 100 10000 101 -20 -5
 * 输出:
 * -20 -10 -9 -5 20 25 98 100 101 10000
 * 
 * 约束：
 * - n最大可达10^7（一千万）
 * - 数值范围较小：-10000 ≤ a_i ≤ 10000
 * - 需要高效的排序算法
 * - 由于数据量很大，需要使用较快的输入输出方式
 * 
 * 算法分析：
 * 由于数值范围有限（-10000到10000，共20001种可能值），
 * 可以使用计数排序（Counting Sort）：
 * 1. 创建计数数组count[20001]（索引0对应-10000，索引20000对应10000）
 * 2. 遍历输入，统计每个数字出现的次数
 * 3. 根据计数数组按顺序输出数字
 * 
 * 时间复杂度：O(n + 20001) ≈ O(n)，线性时间
 * 空间复杂度：O(20001) ≈ 20KB，常数空间
 * 
 * 注意：
 * - 由于n可能很大，不能使用O(n log n)的排序算法（如快速排序、归并排序）
 * - 由于数值范围小，计数排序是最佳选择
 * - 需要处理负数到数组索引的映射：index = num + 10000
 * 
 * 输入输出优化：
 * - 使用scanf/printf而不是cin/cout
 * - 或者使用更快的输入输出函数（如getchar/putchar）
 * - 避免使用endl刷新缓冲区
 */
int main(){
    int n;
    scanf("%d", &n);
    
    int count[20001];
    memset(count, 0, sizeof(count));
    for(int i = 0; i < n; i++){
        int a;
        scanf("%d", &a);
        count[a+10000]++;
    }
    for(int i = 0; i < 20001; i++){
        while(count[i]--){
            printf("%d ", i-10000);
        }
    }
    
    return 0;
}