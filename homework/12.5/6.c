#include "stdio.h"
#include "stdlib.h"

typedef struct {
    int is_alive;
    int index;
}player;
/*
 * 题目描述：可变报数的约瑟夫环游戏
 * 
 * 难度：中等
 * 
 * 输入：
 * - 第1行：正整数n，表示参与游戏的同学总数（1 ≤ n ≤ 1000）
 * - 第2行：n个正整数a₁, a₂, ..., aₙ，表示第i轮报数的淘汰数字
 *   - aᵢ表示第i轮报数时，报数到aᵢ的同学被淘汰
 *   - 1 ≤ aᵢ ≤ 10^8
 * 
 * 输出：
 * - 一行：n个整数，表示每轮被淘汰同学的编号（按淘汰顺序输出）
 * - 数字之间用空格分隔
 * 
 * 游戏规则：
 * 1. n个同学围成一圈，编号1-n，1号和n号相邻
 * 2. 游戏从1号同学开始报数
 * 3. 第1轮：从当前同学开始报数1, 2, 3, ...，报数到a₁的同学被淘汰
 * 4. 第2轮：从被淘汰同学的下一位开始重新报数1, 2, 3, ...，报数到a₂的同学被淘汰
 * 5. 重复以上过程，直到所有人都被淘汰
 * 
 * 关键点：
 * - 每轮淘汰后，剩下的同学保持原有相对顺序，但起始报数点改变
 * - 每轮的淘汰数字aᵢ可能不同
 * - 需要输出完整的淘汰顺序
 * 
 * 示例1：
 * 输入:
 * 10
 * 3 3 3 3 3 3 3 3 3 3
 * 输出:
 * 3 6 9 2 7 1 8 5 10 4
 * 
 * 解释:
 * n=10，每轮都是报数到3的同学淘汰
 * 初始：1 2 3 4 5 6 7 8 9 10（从1号开始报数）
 * 第1轮：报数1(1),2(2),3(3淘汰) → 淘汰3号
 * 剩余：1 2 4 5 6 7 8 9 10（从4号开始报数）
 * 第2轮：报数1(4),2(5),3(6淘汰) → 淘汰6号
 * 第3轮：淘汰9号，第4轮：淘汰2号，...，第10轮：淘汰4号
 * 
 * 示例2：
 * 输入:
 * 10
 * 3 4 5 6 9 20 1 2 4 5
 * 输出:
 * 3 7 2 10 5 4 6 9 8 1
 * 
 * 解释:
 * 每轮淘汰数字不同：
 * 第1轮：a₁=3，淘汰3号
 * 第2轮：a₂=4，从4号开始报数，淘汰7号
 * 第3轮：a₃=5，淘汰2号
 * ...依此类推
 * 
 * 算法分析：
 * 这是一个变种的约瑟夫环问题，每轮淘汰规则不同。
 * 可以使用循环链表或数组模拟，但需要注意：
 * 1. 由于aᵢ可能很大（≤10^8），不能直接模拟报数过程
 * 2. 需要优化：计算相对位置，而不是逐个报数
 * 3. 可以使用数学方法或线段树等数据结构优化
 * 
 * 约束：
 * - n ≤ 1000
 * - aᵢ ≤ 10^8
 * - 需要处理aᵢ远大于当前剩余人数的情况
 * - 时间复杂度应优化，不能是O(n×max(aᵢ))
 * 
 * 提示：
 * 1. 第i轮时剩余人数为n-i+1
 * 2. 淘汰位置 = (当前位置 + aᵢ - 1) % 剩余人数 + 1
 * 3. 注意调整后续编号
 * 4. 可以使用数组模拟剩余人员，每次删除一个元素
 */
int main(){
    int n;
    scanf("%d",&n);
    player* p = (player*)malloc(sizeof(player)*n);
    int* a;
    a = (int*)malloc(sizeof(int)*n);
    for(int i = 0; i < n; i++){
        scanf("%d",&a[i]);
    }
    int alive_num = n;
    int index = 0;
    for(int i = 0; i < n; i++){
        p[i].is_alive = 1;
        p[i].index = i;
    }
    int count = 1;
    int round = 0;
    while(alive_num > 0 && round < n){
        int dead_num = a[round];
        while(!p[index].is_alive){
            index = (index + 1) % n;
        }
        
        if(count == dead_num){
            p[index].is_alive = 0;
            printf("%d ", p[index].index + 1);
            alive_num--;
            count = 1;
            round++;
        } else {
            count++;
            index = (index + 1) % n;
        }
    }
}
