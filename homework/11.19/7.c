#include "stdio.h"
#include "stdlib.h"
/*
 * 题目描述：分类排序
 * 
 * 输入：
 * - 第1行：整数n，表示测试数据的组数
 * - 随后n行：每行一组数据，第一个整数k表示该组数据个数，后面k个整数为待排序数据
 * 
 * 输出：
 * - 对每组数据：先输出所有奇数（按从小到大排序），再输出所有偶数（按从小到大排序）
 * - 元素间用空格分隔，每组输出占一行
 * 
 * 要求：
 * - 奇数在前，偶数在后
 * - 奇数内部按从小到大排序
 * - 偶数内部按从小到大排序
 * - 每组数据的第一个整数（数据个数）不参与排序输出
 * 
 * 示例：
 * 输入:
 * 3
 * 7 1 2 3 4 5 6 7
 * 3 8 5 2
 * 4 2 4 4 8
 * 输出:
 * 1 3 5 7 2 4 6
 * 5 2 8
 * 2 4 4 8
 * 
 * 解释:
 * 第一组：奇数[1,3,5,7]排序后为1,3,5,7；偶数[2,4,6]排序后为2,4,6
 * 第二组：奇数[5]；偶数[8,2]排序后为2,8
 * 第三组：无奇数；偶数[2,4,4,8]排序后为2,4,4,8
 * 
 * 约束：
 * - 每组数据的第一个整数仅表示数据个数，不参与排序输出
 * - 需要分别对奇数和偶数进行内部排序
 */
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        int a[1000];
        int m;
        scanf("%d", &m);
        for(int j = 0; j < m; j++){
            scanf("%d", &a[j]);
        }
        qsort(a, m, sizeof(int), cmp);
        for(int j = 0; j < m; j++){
            if(a[j] % 2 == 1){
                printf("%d ", a[j]);
            }
        }
        for(int j = 0; j<m;j++){
            if(a[j] % 2 == 0){
                printf("%d ", a[j]);
            }
        }
        printf("\n");
    }
}
    